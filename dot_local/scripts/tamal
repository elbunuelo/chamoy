#! /usr/bin/env ruby

require 'date'
require 'fileutils'
require 'optparse'
require 'time'

EDITOR = (ENV['EDITOR'] || 'vi').freeze
NOTES_DIRECTORY = (ENV['NOTES_DIR'] || "#{ENV['HOME']}/notes").freeze
TEMPLATES_DIRECTORY = "#{__dir__}/../note_templates".freeze
MOUSTACHE_REGEX = /{{\s*(?<moustache>.*)\s*}}/

$config = {
  debug: false,
  action: '',
  date: Date.today,
  time: Time.now
}

def log(text, level = 'DEBUG')
  return unless $config[:debug]

  puts "[#{level}][#{Time.now}] #{text}"
end

def open_note
  note_name = $config[:name]
  if note_name.empty?
    puts 'Please provide a note name.'
    exit 1
  end

  file_path = "#{NOTES_DIRECTORY}/#{note_name}.md"
  File.new(file_path, 'w+') unless File.exist? file_path
  system("#{EDITOR} '#{file_path}'")
end

def replace_moustache(moustache)
  operation, *args = moustache.split ' '
  return moustache unless operation == 'format-date'

  args = args.join ' '
  date_regex = /\s*(now|\(\s*date "(?<relative_date>.*)"\s*\))\s*/
  return moustache unless date_match = args.match(date_regex)

  date_function = date_match[0].strip
  date_format = args[date_function.length...].gsub('\'', '').strip

  relative_date = date_match[:relative_date]
  date = Date.today
  if date_function != 'now' && relative_date != 'today'
    relative_date = date_match[:relative_date]
    relative_part, relative_day = relative_date.split ' '

    target_day = Date.parse(relative_day).wday
    days_until = (target_day - date.wday) % 7
    days_until = 7 if days_until == 0
    days_until *= -1 if relative_part == 'last'

    date += days_until
  end

  date.strftime(date_format)
end

def weekly_file_path
  note_name = Time.now.strftime '%Y - Week %W'
  "#{NOTES_DIRECTORY}/#{note_name}.md"
end

def open_weekly_note
  template_path = "#{TEMPLATES_DIRECTORY}/weekly.md"
  file_path = weekly_file_path

  unless File.exist? file_path
    File.open(file_path, 'w+') do |file|
      File.foreach(template_path) do |template_line|
        if matches = template_line.match(MOUSTACHE_REGEX)
          log template_line.gsub(MOUSTACHE_REGEX, replace_moustache(matches[:moustache]))
          log replace_moustache(matches[:moustache])
          file.write(template_line.gsub(MOUSTACHE_REGEX, replace_moustache(matches[:moustache])))
        else
          file.write(template_line)
        end
      end
    end
  end

  system("#{EDITOR} '#{file_path}'")
end

TIME_BLOCK_REGEX = /^###\s+(?<start_time>\d{1,2}:\d{2})\s+-\s+(?<end_time>\d{1,2}:\d{2})/
DAY_HEADER_REGEX = /^##\s+(?<day>Mon|Tue|Wed|Thu|Fri)\s+(?<date>\d{2}\/\d{2})/
THREE_P_HEADER_REGEX = /^##\s+3Ps/
THREE_P_PROGRESS_REGEX = /^###\s+Progress/
THREE_P_PLANNED_REGEX = /^###\s+Planned/
THREE_P_PROBLEMS_REGEX = /^###\s+Problems/
TIME_BLOCK_HEADER_REGEX = /^###\s+(?<start_time>\d{1,2}:\d{2})\s+-\s+(?<end_time>\d{1,2}:\d{2})/
TASK_REGEX = /^\s*-\s+\[(?<status>[ x~])\](?<task>.*)/

def parse_weekly_note
  week = {
    extra: [],
    days:{
    },
    three_p: {
      progress: [],
      planned: [],
      problems: []
    }
  }

  File.open(weekly_file_path) do |file|
    lines = file.readlines
    current_date = nil
    current_time_block = nil
    content_started = false
    three_p_started = false
    current_three_p = nil

    lines.each_with_index do |line, i|
      if match = line.match(DAY_HEADER_REGEX)
        content_started = true
        date = Date.parse("#{match[:date]}/#{Date.today.year}")

        current_date = {
          blocks: [],
          notes: []
        }

        current_time_block = nil
        week[:days][date] = current_date
        next
      end

      if line.match(THREE_P_HEADER_REGEX)
        current_date = nil
        current_time_block = nil
        three_p_started = true
        next
      end

      if three_p_started && line.match(THREE_P_PROGRESS_REGEX)
        current_three_p = :progress
        next
      end

      if three_p_started && line.match(THREE_P_PLANNED_REGEX)
        current_three_p = :planned
        next
      end

      if three_p_started && line.match(THREE_P_PROBLEMS_REGEX)
        current_three_p = :problems
        next
      end

      if current_date && time_block_match = line.match(TIME_BLOCK_REGEX)
        current_time_block = {
          start_time: Time.parse(time_block_match[:start_time]),
          end_time: Time.parse(time_block_match[:end_time]),
          tasks: [],
          notes: []
        }

        current_date[:blocks] << current_time_block
        next
      end

      if current_time_block
        if task_match = line.match(TASK_REGEX)
          status = case task_match[:status]
                   when ' '
                     'pending'
                   when 'x'
                     'done'
                   when '~'
                     'canceled'
                   end

          current_time_block[:tasks] << {
            task: task_match[:task].strip,
            status:
          }
          next
        elsif !line.strip.empty?
          current_time_block[:notes] << line.chomp
          next
        end
      end

      if current_three_p
        week[:three_p][current_three_p] << line.chomp
        next
      end

      week[:extra] << line.chomp unless content_started
    end
  end
  week
end

def output_weekly_note(week)
  week[:extra].each do |extra|
    puts extra
  end

  week[:days].each do |date, day|
    puts "## #{date.strftime('%a %d/%m')}\n\n"

    day[:blocks].each do |block|
      puts "### #{block[:start_time].strftime('%H:%M')} - #{block[:end_time].strftime('%H:%M')}\n\n"

      block[:tasks].each do |task|
        puts "- [ ] #{task[:task]}\n\n"
      end

      block[:notes].each { |line| puts "#{line}\n\n" }
    end
  end

  puts "## 3Ps\n\n"
  puts "### Progress\n"
  week[:three_p][:progress].each { |line| puts "#{line}\n" }

  puts "### Planned\n"
  week[:three_p][:planned].each { |line| puts "#{line}\n" }

  puts "### Problems\n"
  week[:three_p][:problems].each { |line| puts "#{line}\n" }
end

def tasks(date, time)
  week = parse_weekly_note

  blocks = week[:days][date][:blocks]
  block = blocks.detect { |b| time >= b[:start_time] && time <= b[:end_time] }

  return unless block

  puts block[:tasks].map { |t| t[:task] }
end

OptionParser.new do |opts|
  opts.on('-o', '--open NOTE_NAME', 'Open or create note NOTE_NAME in your default editor.') do |name|
    $config[:action] = 'open'
    $config[:name] = name
  end

  opts.on('-w', '--weekly', 'Open the weekly notes in your default editor.') do
    $config[:action] = 'weekly'
  end

  opts.on(
    '-T',
    '--tasks',
    'List the tasks for the specified DATE and TIME. Uses current date and time if not provided') do
      $config[:action] = 'tasks'
  end

  opts.on('-D', '--debug') do
    $config[:debug] = true
  end

  opts.on('-d', '--date DATE') do |date|
    $config[:date] = Date.parse date
  end

  opts.on('-t', '--time TIME') do |time|
    $config[:time] = Time.parse time
  end

  opts.on('-s', '--start-time TIME') do |time|
    $config[:start_time] = Time.parse time
  end

  opts.on('-e', '--end-time TIME') do |time|
    $config[:end_time] = Time.parse time
  end

  opts.on(
    '-a',
    '--add-task TASK',
    'Add a new task for the specified DATE and TIME. Uses current date and time if nor provided') do |task|
      $config[:action] = 'add_task'
      $config[:task] = task
    end
end.parse!

case $config[:action]
when 'open'
  open_note
when 'weekly'
  open_weekly_note
when 'tasks'
  tasks($config[:date], $config[:time])
when'add_task'
  tasks($config[:task], $config[:date], $config[:start_time], $config[:end_time])
end
