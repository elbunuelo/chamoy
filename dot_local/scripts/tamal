#! /usr/bin/env ruby

require 'date'
require 'fileutils'
require 'optparse'
require 'time'

EDITOR = (ENV['EDITOR'] || 'vi').freeze
NOTES_DIRECTORY = (ENV['NOTES_DIR'] || "#{ENV['HOME']}/notes").freeze
TEMPLATES_DIRECTORY = "#{__dir__}/../note_templates".freeze
MOUSTACHE_REGEX = /{{\s*(?<moustache>.*)\s*}}/

$config = {
  debug: false,
  action: '',
  date: Date.today,
  time: Time.now,
  task: '',
  note: ''
}

def log(text, level = 'DEBUG')
  return unless $config[:debug]

  puts "[#{level}][#{Time.now}] #{text}"
end

def open_note
  note_name = $config[:name]
  if note_name.empty?
    puts 'Please provide a note name.'
    exit 1
  end

  file_path = "#{NOTES_DIRECTORY}/#{note_name}.md"
  File.new(file_path, 'w+') unless File.exist? file_path
  system("#{EDITOR} '#{file_path}'")
end

def replace_moustache(moustache)
  operation, *args = moustache.split ' '
  return moustache unless operation == 'format-date'

  args = args.join ' '
  date_regex = /\s*(now|\(\s*date "(?<relative_date>.*)"\s*\))\s*/
  return moustache unless date_match = args.match(date_regex)

  date_function = date_match[0].strip
  date_format = args[date_function.length...].gsub('\'', '').strip

  relative_date = date_match[:relative_date]
  date = Date.today
  if date_function != 'now' && relative_date != 'today'
    relative_date = date_match[:relative_date]
    relative_part, relative_day = relative_date.split ' '

    target_day = Date.parse(relative_day).wday
    days_until = (target_day - date.wday) % 7
    days_until = 7 if days_until == 0
    days_until *= -1 if relative_part == 'last'

    date += days_until
  end

  date.strftime(date_format)
end

def weekly_file_path
  note_name = Time.now.strftime '%Y - Week %W'
  "#{NOTES_DIRECTORY}/#{note_name}.md"
end

def open_weekly_note
  template_path = "#{TEMPLATES_DIRECTORY}/weekly.md"
  file_path = weekly_file_path

  unless File.exist? file_path
    File.open(file_path, 'w+') do |file|
      File.foreach(template_path) do |template_line|
        if matches = template_line.match(MOUSTACHE_REGEX)
          log template_line.gsub(MOUSTACHE_REGEX, replace_moustache(matches[:moustache]))
          log replace_moustache(matches[:moustache])
          file.write(template_line.gsub(MOUSTACHE_REGEX, replace_moustache(matches[:moustache])))
        else
          file.write(template_line)
        end
      end
    end
  end

  system("#{EDITOR} '#{file_path}'")
end

TIME_BLOCK_REGEX = /^###\s+(?<start_time>\d{1,2}:\d{2})\s+-\s+(?<end_time>\d{1,2}:\d{2})/
DAY_HEADER_REGEX = %r{^##\s+(?<day>Mon|Tue|Wed|Thu|Fri)\s+(?<date>\d{2}/\d{2})}
THREE_P_HEADER_REGEX = /^##\s+3Ps/
THREE_P_PROGRESS_REGEX = /^###\s+Progress/
THREE_P_PLANNED_REGEX = /^###\s+Planned/
THREE_P_PROBLEMS_REGEX = /^###\s+Problems/
TIME_BLOCK_HEADER_REGEX = /^###\s+(?<start_time>\d{1,2}:\d{2})\s+-\s+(?<end_time>\d{1,2}:\d{2})/
TASK_REGEX = /^\s*-\s+\[(?<status>[ x~])\](?<task>.*)/

def parse_weekly_note
  week = {
    extra: [],
    days: {},
    three_p: {
      progress: [],
      planned: [],
      problems: []
    }
  }

  File.open(weekly_file_path) do |file|
    lines = file.readlines
    current_date = nil
    current_time_block = nil
    content_started = false
    three_p_started = false
    current_three_p = nil

    lines.each_with_index do |line, _i|
      if match = line.match(DAY_HEADER_REGEX)
        content_started = true
        date = Date.parse("#{match[:date]}/#{Date.today.year}")

        current_date = {
          blocks: [],
          notes: []
        }

        current_time_block = nil
        week[:days][date] = current_date
        next
      end

      if line.match(THREE_P_HEADER_REGEX)
        current_date = nil
        current_time_block = nil
        three_p_started = true
        next
      end

      if three_p_started && line.match(THREE_P_PROGRESS_REGEX)
        current_three_p = :progress
        next
      end

      if three_p_started && line.match(THREE_P_PLANNED_REGEX)
        current_three_p = :planned
        next
      end

      if three_p_started && line.match(THREE_P_PROBLEMS_REGEX)
        current_three_p = :problems
        next
      end

      if current_date && time_block_match = line.match(TIME_BLOCK_REGEX)
        current_time_block = {
          start_time: Time.parse(time_block_match[:start_time]),
          end_time: Time.parse(time_block_match[:end_time]),
          tasks: [],
          notes: []
        }

        current_date[:blocks] << current_time_block
        next
      end

      if current_time_block
        if task_match = line.match(TASK_REGEX)
          status = case task_match[:status]
                   when ' '
                     'pending'
                   when 'x'
                     'done'
                   when '~'
                     'canceled'
                   end

          current_time_block[:tasks] << {
            task: task_match[:task].chomp.strip,
            status:
          }
          next
        elsif !line.strip.empty?
          current_time_block[:notes] << line.chomp
          next
        end
      end

      if current_three_p
        week[:three_p][current_three_p] << line.chomp unless line.chomp.empty?
        next
      end

      week[:extra] << line.chomp unless content_started
    end
  end
  week
end

def output_weekly_note(week)
  output = []
  week[:extra].each do |extra|
    output << "#{extra}\n"
  end

  week[:days].each do |date, day|
    output << "## #{date.strftime('%a %d/%m')}\n\n"

    day[:blocks].each do |block|
      output << "### #{block[:start_time].strftime('%H:%M')} - #{block[:end_time].strftime('%H:%M')}\n"

      block[:tasks].each do |task|
        output << "\n"
        status = case task[:status]
                 when 'pending'
                   ' '
                 when 'done'
                   'x'
                 when 'canceled'
                   '~'
                 end
        output << "- [#{status}] #{task[:task]}\n"
      end
      output << "\n" unless block[:notes].empty?

      block[:notes].each { |line| output << "#{line}\n" }
      output << "\n"
    end
  end

  output << "## 3Ps\n\n"
  output << "### Progress\n\n"
  week[:three_p][:progress].each { |line| output << "#{line}\n" }
  output << "\n"

  output << "### Planned\n\n"
  week[:three_p][:planned].each { |line| output << "#{line}\n" }
  output << "\n"

  output << "### Problems\n\n"
  week[:three_p][:problems].each { |line| output << "#{line}\n" }
  output << "\n"

  if $config[:debug]
    puts output.join ''
  else
    File.open(weekly_file_path, 'w') do |f|
      f.write output.join ''
    end
  end
end

def tasks(date, time)
  week = parse_weekly_note

  blocks = week[:days][date][:blocks]
  block = blocks.detect { |b| time >= b[:start_time] && time <= b[:end_time] }

  return unless block

  puts(block[:tasks].map { |t| t[:task] })
end

def add_task(task, date, start_time, end_time)
  week = parse_weekly_note
  blocks = week[:days][date][:blocks]

  block_index = 0
  blocks.each_with_index do |block, i|
    next if block[:start_time] < start_time

    block_index = i
    if block[:start_time] == start_time
      block[:end_time] = [block[:end_time], end_time].max
    else
      blocks.insert(block_index, {
                      start_time:,
                      end_time:,
                      tasks: [],
                      notes: []
                    })
    end
    break
  end

  blocks[block_index][:tasks] << { task:, status: 'pending' }

  output_weekly_note week
end

def add_note(note, date, start_time, end_time)
  week = parse_weekly_note
  blocks = week[:days][date][:blocks]

  block_index = 0
  blocks.each_with_index do |block, i|
    next if block[:start_time] < start_time

    block_index = i
    if block[:start_time] == start_time
      block[:end_time] = [block[:end_time], end_time].max
    else
      blocks.insert(block_index, {
                      start_time:,
                      end_time:,
                      tasks: [],
                      notes: []
                    })
    end
    break
  end

  blocks[block_index][:notes] << "- #{note}"

  output_weekly_note week
end

def add_three_p(note, section)
  week = parse_weekly_note
  week[:three_p][section.to_sym] << "- #{note}"

  output_weekly_note week
end

def update_task(task_index, status, date, start_time)
  week = parse_weekly_note
  blocks = week[:days][date][:blocks]

  block_index = 0
  blocks.each_with_index do |block, i|
    next if block[:start_time] < start_time

    block_index = i
    break
  end

  blocks[block_index][:tasks][task_index][:status] = status

  output_weekly_note week
end

OptionParser.new do |opts|
  opts.on('-o', '--open NOTE_NAME', 'Open or create note NOTE_NAME in your default editor.') do |name|
    $config[:action] = 'open'
    $config[:name] = name
  end

  opts.on('-w', '--weekly', 'Open the weekly notes in your default editor.') do
    $config[:action] = 'weekly'
  end

  opts.on(
    '-T',
    '--tasks',
    'List the tasks for the specified DATE and TIME. Uses current date and time if not provided'
  ) do
    $config[:action] = 'tasks'
  end

  opts.on('-D', '--debug') do
    $config[:debug] = true
  end

  opts.on('-d', '--date DATE') do |date|
    $config[:date] = Date.parse date
  end

  opts.on('-t', '--time TIME') do |time|
    $config[:time] = Time.parse time
  end

  opts.on('-s', '--start-time TIME') do |time|
    $config[:start_time] = Time.parse time
  end

  opts.on('-e', '--end-time TIME') do |time|
    $config[:end_time] = Time.parse time
  end

  opts.on('-a', '--add-task TASK',
          'Add a new task for the specified DATE and TIME. Uses current date and time if nor provided') do |task|
    $config[:action] = 'add_task'
    $config[:task] = task
  end

  opts.on('-n', '--note NOTE') do |note|
    $config[:action] = 'add_note'
    $config[:note] = note
  end

  opts.on('-3', '--three-p SECTION', 'Add the note to the specified 3P section') do |section|
    $config[:action] = 'three_p'
    $config[:section] = section.downcase
  end

  opts.on('-u', '--update-task INDEX') do |index|
    $config[:action] = 'update_task'
    $config[:index] = index.to_i
  end

  opts.on('-S', '--status STATUS') do |status|
    $config[:status] = status
  end
end.parse!

case $config[:action]
when 'open'
  open_note
when 'weekly'
  open_weekly_note
when 'tasks'
  tasks($config[:date], $config[:time])
when 'add_task'
  add_task($config[:task], $config[:date], $config[:start_time], $config[:end_time])
when 'add_note'
  add_note($config[:note], $config[:date], $config[:start_time], $config[:end_time])
when 'three_p'
  add_three_p($config[:note], $config[:section])
when 'update_task'
  update_task($config[:index], $config[:status], $config[:date], $config[:start_time])
end
